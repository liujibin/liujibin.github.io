<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Activity启动模式</title>
      <link href="/2018/07/10/activity-qi-dong-mo-shi/"/>
      <url>/2018/07/10/activity-qi-dong-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/IHEV9tZ.jpg" width="100%"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个Android应用里面通常都会包含多个Activity，这些Activity需要相互跳转，启动一个应用，就会创建一个与之对应的Task（任务栈），系统通过Task来管理这些Activity的实例，launchMode在Activity的跳转中扮演着非常重要的角色，它决定了Task中同一个Activity的实例是否重用、多个Task中同一个Activity的实例是否重用。下面来了解下Activity的四种launchMode。<br><a id="more"></a></p><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是Activity默认的启动模式，如果不对Activity设置launchMode的情况下，默认就是这种模式启动。启动同一个Activity的时候，不管同一个Task里面是否已有这个Activity的实例、也不管这个Activity的实例是否在栈顶，都会重新创建Activity的实例。这种模式在一个Task里同一个Activity会出现多个实例。</p><h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式和Standard模式有一点相似，在同一个Task里面同一个Activity也是会出现相同的实例的。启动Activity是，如果当前Task已有这个Activity的实例，并且在栈顶，就会直接调用，不会去新建实例；如果已有这个Activity的实例，但不在栈顶，就会新建一个这个Activity的实例。</p><h3 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式启动，在同一个Task里面是单例的。启动一个Activity的时候，如果当前Task里面已经有这个Activity的实例，不去新建实例，直接使用已有的实例，同时，如果已有的实例在栈顶，直接使用；如果不在栈顶，则这个实例上面的全部出栈，已有实例出现在栈顶使用。</p><h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式启动，也是单例，不同于SingleTask的同一个Task单例，这种模式启动的Activity在整个系统中是单例。启动Activity的时候，会去新建一个单独的Task，这个Task里面只有一个实例，这个Activity的实例，在系统中任何应用启动这个Activity的时候都直接调用这个Task里面的实例。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础知识 </tag>
            
            <tag> Activity系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Native安装配置运行打包</title>
      <link href="/2018/06/28/react-native-an-zhuang-pei-zhi-yun-xing-da-bao/"/>
      <url>/2018/06/28/react-native-an-zhuang-pei-zhi-yun-xing-da-bao/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/Q860HnW.jpg" width="100%"></p><p><div style="text-align:center; color:#aaaaaa; margin-top:2px;">总裁吸螺镇楼</div><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旨在整理最新的React-Native安装配置运行打包流程详细、过程中的注意点以及可能会遇到的坑，大牛请无视^_^。<br><a id="more"></a></p><h2 id="React-Native简介"><a href="#React-Native简介" class="headerlink" title="React Native简介"></a>React Native简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN基于JavaScript语言，使用JSX，以及CSS来开发移动应用，这使得熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。<br><img src="https://i.imgur.com/KM2U2Bn.jpg" alt=""></p><ul><li>React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。  </li><li>React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere)  </li><li>Facebook已经在多项产品中使用了React Native，并且将持续地投入建设React Native。  </li></ul><h3 id="React-Native主要特性如下"><a href="#React-Native主要特性如下" class="headerlink" title="React Native主要特性如下"></a>React Native主要特性如下</h3><h4 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用React Native，你可以使用标准的平台组件，例如iOS的UITabBar或安卓的Drawer。 这使你的app获得平台一致的视觉效果和体验，并且获得最佳的性能和流畅性。 使用对应的React component，就可以轻松地把这些原生组件整合到你的React Native应用中， 例如TabBarIOS和DrawerLayoutAndroid。</p><h4 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Javascript代码和原生平台之间的所有操作都是异步执行的，并且原生模块还可以根据需要创建新的线程。这意味着你可以在主线程解码图片，然后在后台将它保存到磁盘，或者在不阻塞UI的情况下计算文字大小和界面布局等等。所以React Native开发的app天然具备流畅和反应灵敏的优势。Javascript和原生代码之间的通讯是完全可序列化的，这使得我们可以借助Chrome开发者工具去调试应用，而不论应用运行在模拟器还是真机上。</p><h4 id="触摸事件处理"><a href="#触摸事件处理" class="headerlink" title="触摸事件处理"></a>触摸事件处理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React Native实现了一个强大的触摸事件处理系统，可以在复杂的View层次关系下正确地处理触摸事件。同时还提供了高度封装的组件如TouchableHighlight等，可以直接嵌入到ScrollView或者其它的元素中，无需额外配置。</p><h4 id="弹性盒-Flexbox-和样式"><a href="#弹性盒-Flexbox-和样式" class="headerlink" title="弹性盒(Flexbox)和样式"></a>弹性盒(Flexbox)和样式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制view的布局应当简单易行，这就是为什么React Native从web中借鉴了Flexbox模型。Flexbox让大多数常见的UI布局构建变得简单（譬如带有外衬margin和内衬padding，且堆叠在一起的多个矩形）。React Native还支持多种常见的web样式，例如fontWeight等。抽象样式表提供了一个高性能的机制来声明所有的样式和布局，并且可以直接应用到你的组件中。</p><h4 id="兼容通用标准"><a href="#兼容通用标准" class="headerlink" title="兼容通用标准"></a>兼容通用标准</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React Native致力于改进视图代码的编写方式。除此之外，我们还吸纳了web生态系统中的通用标准，并在必要的时候为这些API提供兼容层。如此一来，npm上的许多库就可以在React Native中直接使用。这样的兼容层有XMLHttpRequest, window.requestAnimationFrame, navigator.geolocation等。我们还在努力增加更多的API，并且十分欢迎开源社区进行贡献。</p><h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用React Native，无需编写一行原生代码即可创造一款不错的app。尽管如此，使用自定义的原生视图和模块来扩展React Native也非常容易 —— 这意味着你现有的所有工作都可以被复用，你喜欢的各种原生库都可以被导入。<br><img src="https://i.imgur.com/Q4BEuga.jpg" alt=""></p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>目标平台：<font>IOS</font> <font style="margin-left:10px; background-color:#ee3355; padding:5px;">Android</font>  &nbsp;&nbsp;&nbsp;开发平台：MacOs <font style="margin-left:10px;">Linux</font> <font style="margin-left:10px; background-color:#ee3355; padding:5px;">Windows</font>  </p><h3 id="必要的软件安装"><a href="#必要的软件安装" class="headerlink" title="必要的软件安装"></a>必要的软件安装</h3><h4 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chocolatey是一个Windows上的包管理器，类似于linux上的yum和 apt-get。 你可以在其<a href="https://chocolatey.org/" target="_blank" rel="noopener">官方网站</a>上查看具体的使用说明。一般的安装步骤应该是下面这样：</p><pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</code></pre><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，使用Chocolatey来安装软件的时候，需要以管理员的身份来运行命令提示符窗口。译注：chocolatey的网站可能在国内访问困难，导致上述安装命令无法正常完成。请使用稳定的翻墙工具。 如果你实在装不上这个工具，也不要紧。下面所需的python2和nodejs你可以分别单独去对应的官方网站下载安装即可。  </p></blockquote><h4 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h4><p>打开命令提示符窗口，使用Chocolatey来安装Python 2.</p><blockquote><p>注意目前不支持Python 3版本。  </p></blockquote><pre><code>choco install python2</code></pre><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>打开命令提示符窗口，使用Chocolatey来安装NodeJS。  </p><pre><code>choco install nodejs.install</code></pre><p>安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！  </p><pre><code>npm config set registry https://registry.npm.taobao.org --global  npm config set disturl https://npm.taobao.org/dist --global</code></pre><h4 id="Yarn、React-Native的命令行工具（react-native-cli）"><a href="#Yarn、React-Native的命令行工具（react-native-cli）" class="headerlink" title="Yarn、React Native的命令行工具（react-native-cli）"></a>Yarn、React Native的命令行工具（react-native-cli）</h4><p><a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">Yarn</a>是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><pre><code>npm install -g yarn react-native-cli</code></pre><p>安装完yarn后同理也要设置镜像源：</p><pre><code>yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global</code></pre><blockquote><p>如果你遇到EACCES: permission denied权限错误，可以尝试运行下面的命令（限linux系统）： sudo npm install -g yarn react-native-cli.</p></blockquote><p>安装完yarn之后就可以用yarn代替npm了，例如用yarn代替npm install命令，用yarn add 某第三方库名代替npm install –save 某第三方库名。</p><blockquote><p>注意：目前npm5（发文时最新版本为5.0.4）存在安装新库时会删除其他库的问题，导致项目无法正常运行。请尽量使用yarn代替npm操作。</p></blockquote><h4 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h4><p>React Native目前需要Android Studio2.0或更高版本。Android Studio需要Java Development Kit [JDK] 1.8（暂不支持更高版本）。具体安装配置见<a href="http://liujibin.cn/2018/02/27/android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">android开发环境搭建及配置</a></p><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><pre><code>react-native init FirstProject</code></pre><p>初始化创建项目，工程名“FirstProject”。</p><pre><code>react-native run-android</code></pre><p>进入到工程目录执行，运行项目，可以在模拟器或者终端看到效果。</p><pre><code>adb devices</code></pre><p>查看当前可调试设备或者模拟器。</p><pre><code>react-native run-android</code></pre><p>在设备上运行应用。</p><h3 id="在设备上运行"><a href="#在设备上运行" class="headerlink" title="在设备上运行"></a>在设备上运行</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你需要开启USB调试才能在你的设备上安装你的APP。首先，确定你已经打开设备的USB调试开关<br>确保你的设备已经成功连接。可以输入adb devices来查看:</p><blockquote><p>$ adb devices<br>List of devices attached<br>emulator-5554 offline   # Google模拟器<br>14ed2fcc device         # 真实设备</p></blockquote><p>在右边那列看到device说明你的设备已经被正确连接了。注意，你只应当连接仅仅一个设备。<br>如果你连接了多个设备（包含模拟器在内），后续的一些操作可能会失败。拔掉不需要的设备，或者关掉模拟器，确保adb devices的输出只有一个是连接状态。<br>现在你可以运行react-native run-android来在设备上安装并启动应用了。<br>在真机上运行时可能会遇到白屏的情况，请找到并开启悬浮窗权限。</p><blockquote><p>你还可以运行react-native run-android –variant=release来安装release版的应用。当然你需要先配置好签名，且此时无法再开启开发者菜单。注意在debug和release版本间来回切换安装时可能会报错签名不匹配，此时需要先卸载前一个版本再尝试安装。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative基础 </tag>
            
            <tag> baseWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View事件分发处理机制</title>
      <link href="/2018/05/18/view-shi-jian-fen-fa-chu-li-ji-zhi/"/>
      <url>/2018/05/18/view-shi-jian-fen-fa-chu-li-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/SDONBZ0.jpg" width="100%"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当Android手机屏幕监听到用户的动作，如何将事件传递给对应的控件呢？Android给我们提供了一套完善的事件传递、处理机制，可以很好地帮助开发者完成事件的分配和处理。要搞清楚触摸事件的分发机制，我们首先需要了解什么是触摸事件以及Android的View结构。<br><a id="more"></a></p><h2 id="View结构"><a href="#View结构" class="headerlink" title="View结构"></a>View结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android中控件大致分为两类，即View控件和ViewGroup控件，ViewGroup也是继承自View，ViewGroup中可以包含多个View或者ViewGroup，并管理其包含的子控件。通过ViewGroup，整个界面形成了树形结构，也就是我们常说的控件树，上层控件要负责下层控件的测量与绘制、以及传递交互事件。每个控件树的顶部都有一个ViewParent对象，这是整棵树的控制核心，所有的交互管理事件都由它来统一调度分配，从而进行整个视图的控制。<br><img src="https://i.imgur.com/V5JdDWR.png" alt="View树结构"></p><h2 id="什么是触摸事件"><a href="#什么是触摸事件" class="headerlink" title="什么是触摸事件"></a>什么是触摸事件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户点击屏幕或者按钮的时候，通常会产生两到三个事件：手指按下去，事件一；手指抬起来，事件二；如果在这过程中不小心移动了一下，事件三。Android中将触摸事件封装成一个类MotionEvent，当重写onTouchEvent方法的时候，会发现这个方法的参数就是MotionEvent实例。其实只要重写触摸事件处理的相关方法，参数基本都是MotionEvent的实例，由此可见MotionEvent这个类非常的重要，是事件处理的核心类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们主要可以从MotionEvent类中获取哪些信息？触摸点的坐标，可以通过MotionEvent对象的方法event.getX()和event.getRawX()分别获取到相对于视图坐标系和安卓坐标系的坐标。还可以获取到触摸事件的类型，根据event.getAction()得到的事件类型判断属于哪种事件（MotionEvent.ACTION_DOWN，MotionEvent.ACTION_MOVE，MotionEvent.ACTION_UP等），在对应的类型下做出对应的处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里可能会觉得事件的处理还是很简单的，就坐标点和事件的类型，但事实上我们的Android View是呈树形结构的，可以ViewGroup内嵌View，也可以ViewGroup内嵌ViewGroup，层层嵌套，可以有很复杂的View树形结构。那我们的触摸事件只有一个，到底应该在哪个层级的View进行处理，是父View处理还是子View处理，这里就需要用到我们的事件分发拦截了。</p><h2 id="事件分发处理的流程"><a href="#事件分发处理的流程" class="headerlink" title="事件分发处理的流程"></a>事件分发处理的流程</h2><h3 id="三个重要方法"><a href="#三个重要方法" class="headerlink" title="三个重要方法"></a>三个重要方法</h3><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> View系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View的绘制之测量（measure）</title>
      <link href="/2018/05/10/view-de-hui-zhi-measure/"/>
      <url>/2018/05/10/view-de-hui-zhi-measure/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/0hUdNSC.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><a id="more"></a><br>    —小故事说明绘制View需要的步骤</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h4 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h4><h3 id="super-onMeasure-分析"><a href="#super-onMeasure-分析" class="headerlink" title="super.onMeasure()分析"></a>super.onMeasure()分析</h3><h4 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h4><h4 id="继承现成控件"><a href="#继承现成控件" class="headerlink" title="继承现成控件"></a>继承现成控件</h4><h4 id="继承ViewGroup"><a href="#继承ViewGroup" class="headerlink" title="继承ViewGroup"></a>继承ViewGroup</h4>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> View系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View坐标系</title>
      <link href="/2018/05/04/view-zuo-biao-xi/"/>
      <url>/2018/05/04/view-zuo-biao-xi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/pr9ij4G.jpg" width="100%"><br>“学而不思则罔，思而不学则殆”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;————孔子<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Android View体系作为Android基础知识里面比较基础也比较核心的部分，其重要性不比四大组件差多少，从本篇开始将开始整理View的相关知识，形成系列。本篇主要就View的坐标做介绍，在后续的文章里还会涉及到事件的分发、View的绘制等内容。<br><a id="more"></a></p><h2 id="View简介"><a href="#View简介" class="headerlink" title="View简介"></a>View简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View是Android里面所有控件的基类，ViewGroup也是继承自View，我们常用的控件都是继承自View，掌握好View的相关知识，对后面的界面开发有很大帮助。View这一块内容，展示是基础，交互才是精髓，常见的有点击、长按、滑动等交互事件，点击、长按比较简单，滑动事件离不开坐标点，下面就坐标角度来分析一下。</p><h2 id="安卓里的坐标系和数学坐标系的区别"><a href="#安卓里的坐标系和数学坐标系的区别" class="headerlink" title="安卓里的坐标系和数学坐标系的区别"></a>安卓里的坐标系和数学坐标系的区别</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到坐标系，大家最熟悉的还是数学里面最常用到的坐标系，如下图。在数学坐标系里面，坐标轴向上是y轴正方向，向右是x轴正方向。<br><img src="https://i.imgur.com/Q1nr7D3.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来看看我们安卓里面的坐标系，如下图。和数学坐标系还是有区别的，向右是x轴正方向，向下是y轴的正方向，相当于数学坐标系上下颠倒了一下，在后续的开发里不要理解错了。<br><img src="https://i.imgur.com/gZ27fJH.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在手机屏幕上坐标轴的体现为，如下图。假如粉红色区域为手机屏幕，屏幕的左上角是坐标系的原点(0,0)，沿左边向下为y轴正方向，沿顶边向右为x轴正方向。<br><img src="https://i.imgur.com/8gDNi0p.png" alt=""></p><h2 id="安卓里的坐标系"><a href="#安卓里的坐标系" class="headerlink" title="安卓里的坐标系"></a>安卓里的坐标系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Android坐标系主要分为两种：Android坐标、视图坐标。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a、Android坐标：Android坐标是以屏幕的左上角为原点，水平向右为x正方向，垂直向下为y轴正方向。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b、视图坐标：视图坐标和Android坐标相似，也是从原点水平向右代表x正方向，垂直向下代表y正方向，但是原点不再是屏幕的坐上角，而是父View的左上角作为原点，如下图所示。<br><img src="https://i.imgur.com/cDaGVzh.png" alt="">  </p><h3 id="相对坐标和绝对坐标的区别"><a href="#相对坐标和绝对坐标的区别" class="headerlink" title="相对坐标和绝对坐标的区别"></a>相对坐标和绝对坐标的区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过一幅图来了解相对坐标和绝对坐标的区别。如下图：<br><img src="https://i.imgur.com/YODZCsM.png" alt="">  </p><h4 id="View获取自己坐标的事件："><a href="#View获取自己坐标的事件：" class="headerlink" title="View获取自己坐标的事件："></a>View获取自己坐标的事件：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLeft()：当前View的左边离父控件左边的距离；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getTop()：当前View的顶边离父控件顶边的距离；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getRight()：当前View的右边距父控件左边的距离；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getBottom()：当前View的底边距父控件的顶边的距离；  </p><h4 id="View获取自身宽高："><a href="#View获取自身宽高：" class="headerlink" title="View获取自身宽高："></a>View获取自身宽高：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getWidth()：当前View自身的宽度；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getHeight()：当前View自身的高度；  </p><h4 id="MotionEvent获取坐标："><a href="#MotionEvent获取坐标：" class="headerlink" title="MotionEvent获取坐标："></a>MotionEvent获取坐标：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getX()：当前触摸点距当前View的左边的距离；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getY()：当前触摸点距当前View的顶边的距离；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getRawX()：当前触摸点距屏幕左边的距离；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getRawY()：当前触摸点距屏幕的顶边的距离；    </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里getX()、getY()获取到的就是视图坐标的坐标点，getRawX()、getRawY()获取到的就是Android坐标的坐标点。结合上图和这些相关的事件，很轻易就可以理解这两种坐标了。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> View系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android MVP模式学习</title>
      <link href="/2018/04/26/android-mvp-mo-shi-xue-xi/"/>
      <url>/2018/04/26/android-mvp-mo-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/syCRVfC.jpg" width="100%"></p><h2 id="MVP简介"><a href="#MVP简介" class="headerlink" title="MVP简介"></a>MVP简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着时代的发展，移动端UI越来越丰富、业务越来越复杂，用户对界面的美观、渲染的速度、数据读取的速度要求也越来越高。为了在保证拥有酷炫的UI、复杂的业务逻辑的条件下给用户更好的体验，需要对view、model、controller职责进行细分，让view专注于处理数据的可视化以及和用户的交互、让model专注于数据的处理。一种新的模式MVP（Model - View - Presenter）应运而生。<br><a id="more"></a></p><h2 id="MVP和MVC的差异"><a href="#MVP和MVC的差异" class="headerlink" title="MVP和MVC的差异"></a>MVP和MVC的差异</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVP模式是从MVC模式理念的基础上衍生出来的，在MVC的基础上对V和M进行了绝对的解耦，两者之间只有通过Presenter才能通信，优化了V层和C层，职责划分更明确、单一。MVC中，M层和V层是可以通信的，MVP中M层和V层是完全隔离的，只能通过P层来通信，如图（这里借图一用）。<br><img src="https://i.imgur.com/3aUWfu2.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MVC模式时期，由于UI越来越丰富、逻辑处理越来越复杂，Activity中对UI的活动展示以及和用户的交互也越来越复杂，代码量比较大，同时受限于Android的线程安全以及很多时候需要使用到Activity的生命周期，我们有不少的Controller层的代码也会写在Activity里面，也就是Activity同时承担了View层和部分Controller层的工作，影响开发效率，不利于维护和扩展。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，我们将复杂的逻辑移至另外一个类Presenter，让Activity只负责UI的展示以及和用户的交互。View层，创建View Interface，定义好View层的活动事件，Activity加载布局、实现View Interface，将View Interface传入Presenter实例，通过View Innterface和Presenter实现交互；Model层，负责存储、检索、操纵数据，可以通过创建一个Model Interface来进一步实现解耦；Presenter层，作为View和Model交互的中间枢纽，负责接收用户操作，调用Model层，将数据反馈到View层展示给用户。  </p><h2 id="选择MVP的必要性"><a href="#选择MVP的必要性" class="headerlink" title="选择MVP的必要性"></a>选择MVP的必要性</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）降低了耦合性；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）各模块职责划分明确，利于协同开发；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）业务逻辑独立出来，通过接口调用，方便单元测试；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）代码重用性高；</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里跟随很多大牛的脚步，同样使用登录页面来作为第一次体验MVP的示例。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①登录页面布局activity_main.xml代码，布局比较简单，两个输入框，一个登录按钮，一个加载等待条（默认隐藏）。  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.LoginActivity&quot;    android:padding=&quot;20dp&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;vertical&quot;        android:layout_centerVertical=&quot;true&quot;        &gt;        &lt;EditText            android:id=&quot;@+id/userName&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;50dp&quot;            android:hint=&quot;用户名&quot;/&gt;        &lt;EditText            android:id=&quot;@+id/password&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;50dp&quot;            android:layout_marginTop=&quot;5dp&quot;            android:hint=&quot;密码&quot;/&gt;        &lt;Button            android:id=&quot;@+id/loginBtn&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;60dp&quot;            android:layout_marginTop=&quot;10dp&quot;            android:text=&quot;Login&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;ProgressBar        android:id=&quot;@+id/progressBar&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;        android:visibility=&quot;gone&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②View Interface，这里定义的是View的活动，这里登录页面存在的活动有（显示加载等待框、隐藏加载等待框、返回登录成功或者登录失败），所以ILoginView代码如下。</p><pre><code>public interface ILoginView {    /*显示等待框*/    void showProgress();    /*隐藏等待框*/    void hideProgress();    /*登录成功*/    void loginSuccess();    /*登录失败*/    void loginError();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③Model Interface，需要在model中去判断用户名和密码是否正确，并返回处理结果，所以ILoginModel需要定义一个checkLogin方法，再定义一个回调的内部接口，因为只有P能主动通信M，M不能主动通信P，所有这里采用回调来返回结果。</p><pre><code>public interface ILoginModel {    /*回调接口*/    interface OnLoginListener{        /*登录成功回调*/        void loginSuccess();        /*登录失败回调*/        void loginError();    }    /*判断输入的用户名、密码，调用内部接口回调*/    void checkLogin(String userName,String password,OnLoginListener listener);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④实现ILoginModel，这里虚拟登录。</p><pre><code>public class LoginModelImpl implements ILoginModel {    @Override    public void checkLogin(final String userName, final String password, final OnLoginListener listener) {        new Handler().postDelayed(new Runnable() {            @Override            public void run() {                if(userName.equals(&quot;1&quot;) &amp;&amp; password.equals(&quot;1&quot;)){                    listener.loginSuccess();                }else{                    listener.loginError();                }            }        },3000);    }}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤Presenter Interface，Presenter接收用户点击按钮的事件，然后调用Model处理数据，ILoginPresenter需要toLogin方法。</p><pre><code>public interface ILoginPresenter {    void toLogin(String userName,String password);}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥实现Presenter，P层作为V和M的交互媒介，需要同时持有V和M，在M处理完返回的时候还需要通知到V层，所以还要实现M层的回调接口。由于V层可以主动沟通P层，所以V层和P层互相持有，这里V层直接在构造函数里传递过来。</p><pre><code>public class LoginPresenterImpl implements ILoginPresenter,                                    ILoginModel.OnLoginListener {    private ILoginView mView;    private ILoginModel mModel;    public LoginPresenterImpl(ILoginView iLoginView) {        mView = iLoginView;        mModel = new LoginModelImpl();    }    @Override    public void toLogin(String userName, String password) {        mView.showProgress();        mModel.checkLogin(userName,password,this);    }    @Override    public void loginSuccess() {        mView.hideProgress();        mView.loginSuccess();    }    @Override    public void loginError() {        mView.hideProgress();        mView.loginError();    }}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑦View实现加载，这里在Acitvity中操作，实现View Interface，实例化Presenter，将View Interface作为参数传递给Presenter。</p><pre><code>package liu.wolf.firstmvpdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ProgressBar;import android.widget.Toast;import liu.wolf.firstmvpdemo.presenter.LoginPresenterImpl;import liu.wolf.firstmvpdemo.view.ILoginView;public class LoginActivity extends AppCompatActivity implements                                                 ILoginView{    private ProgressBar progressBar;    private EditText userName,password;    private Button loginBtn;    private LoginPresenterImpl mPresenter = null;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mPresenter = new LoginPresenterImpl(this);        progressBar = findViewById(R.id.progressBar);        userName = findViewById(R.id.userName);        password = findViewById(R.id.password);        loginBtn = findViewById(R.id.loginBtn);        loginBtn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                mPresenter.toLogin(userName.getText().toString(),                        password.getText().toString());            }        });    }    @Override    public void showProgress() {        progressBar.setVisibility(View.VISIBLE);    }    @Override    public void hideProgress() {        progressBar.setVisibility(View.GONE);    }    @Override    public void loginSuccess() {        Toast.makeText(LoginActivity.this,&quot;登录成功！&quot;,                Toast.LENGTH_LONG).show();    }    @Override    public void loginError() {        Toast.makeText(LoginActivity.this,&quot;登录失败！&quot;,                Toast.LENGTH_LONG).show();    }}</code></pre><p>代码下载：<a href="https://download.csdn.net/download/liujibin1836591303/10374061" title="https://download.csdn.net/download/liujibin1836591303/10374061" target="_blank" rel="noopener">https://download.csdn.net/download/liujibin1836591303/10374061</a><br><a href="http://liujibin.cn/2018/04/26/Android%20MVP%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">阅读原文</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
            <tag> MVP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter构建布局</title>
      <link href="/2018/03/22/flutter-gou-jian-bu-ju/"/>
      <url>/2018/03/22/flutter-gou-jian-bu-ju/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;待续……<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Flutter初识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter第一个应用</title>
      <link href="/2018/03/20/flutter-di-yi-ge-ying-yong/"/>
      <url>/2018/03/20/flutter-di-yi-ge-ying-yong/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里是根据官方给的案例重新稍作整理，对基础工程以及界面交互等做一个初步的了解，具体知识点会在后面的文章做详细的介绍。通过本文可以了解到以下几点知识：  </p><ul><li>创建初始Flutter应用；  </li><li>使用外部的Package；  </li><li>使用有状态的Widget；  </li><li>创建ListView；  </li><li>添加可交互操作；  </li><li>跳转新页面。<a id="more"></a><strong>IDE：Android Studio</strong><h2 id="工程主要文件"><a href="#工程主要文件" class="headerlink" title="工程主要文件"></a>工程主要文件</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们创建一个Flutter项目，项目名称单词首字母小写，下划线连接，例如first_project，而不是firstProject或者FirstProject。创建项目完成后，如下图。今天我们主要会用到两个文件lib/main.dart、pubspec.yaml。main.dart是main方法所在的文件，项目的入口，pubspec.yaml里面是对第三方Packages的引用依赖。<br><img src="https://i.imgur.com/wMWX56S.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目创建后，main.dart文件里面会默认生成一些构建简单页面的代码以及一些注释。连接上设备，run一下，可以看到效果，如下图。<br><img src="https://i.imgur.com/uM4d7Sy.jpg" width="40%"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不是我们要的，我们只想要Hello World页面(#^.^#)。我们把main.dart里面的代码全部清掉，自己写一个Hello World页面，代码如下。导入flutter的material包，定义main方法并指定运行的入口页面类，定义一个入口页面类继承StatelessWidget，创建Material app，Material库的Scaffold提供了默认的导航栏appBar以及构成主页面的body属性。下面我们通过Widget来了解页面树结构的构建。<br>```<br>import ‘package:flutter/material.dart’;</li></ul><p>void main() =&gt; runApp(new MyApp());</p><p>class MyApp extends StatelessWidget{<br>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return new MaterialApp(<br>      title: “demo app”,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(“Welcome to flutter”),<br>        ),<br>        body: new Center(<br>          child: new Text(“Hello World”),<br>        ),<br>      ),<br>    );<br>  }</p><p>}</p><pre><code>界面运行如下：&lt;img src=&quot;https://i.imgur.com/HbpGKFJ.jpg&quot; width=&quot;40%&quot;/&gt;## 引用外部的Package&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里以一个开源的软件包english_words来做个示例，这个包里包含了数千个常用的英文单词和一些功能。可以在[pub.dartlang.org](https://pub.dartlang.org/flutter/)上查到很多有用的开源工具包。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pubspec.yaml文件管理着Flutter应用程序的静态资源。在文件中添加english_words依赖如下：</code></pre><p>dependencies:<br>  flutter:<br>    sdk: flutter</p><p>  cupertino_icons: ^0.1.0<br>  english_words: ^3.1.0</p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;点击右上角的Packages get，将包拉到项目中。控制台输出如下表示完成。</code></pre><p>–no-color packages get<br>Running “flutter packages get” in first_project…<br>Process finished with exit code 0</p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将包导入到lib/main.dart中。</code></pre><p>import ‘package:flutter/material.dart’;<br>import ‘package:english_words/english_words.dart’;</p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们在代码中使用这个包里面的WordPair类，生成随机的单词，代替Hello World，代码如下。红线是新加的代码，然后点一下工具栏的Flutter Hot Reload按钮，就可以直接热重载界面。生成随机单词代替了Hello World。![](https://i.imgur.com/T8IBdQd.png)&lt;img src=&quot;https://i.imgur.com/Az2GUsy.jpg&quot; width=&quot;40%;&quot;/&gt;## 使用有状态的Widget&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过上面的代码可以看到，app继承了一个使它自己变成一个widget的StatelessWidget类。在Flutter里面，大多时候可以把一切都看作widget。widget主要方法是提供了一个build()方法，描述如何根据其他更低级别的widget来对这个widget进行展示。上面那段示例包含了Text child widget、Center widget，Center widget可以将它所有的子树都对齐到屏幕中心。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stateless widget是不可以改变的，这就意味着它的属性也不能改变，所有的值都是final修饰的。Stateful widget保持的状态在生命周期内可能会发生变化，要实现一个有状态的widget至少需要两个条件：1）一个StatefulWidget类；2）这个类创建一个State类的实例。StatefulWidget类本身是不可变的，但是State类可以存在整个widget生命周期中。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此处的示例我们会在main.dart里创建一个有状态的widget类RandomWords继承StatefulWidget，再创建一个继承了State类的RandomWordsState类，然后在RandomWords类里实例化后者，RandomWordsState会保存RandomWords的状态,实现一个有状态的widget。代码如下。</code></pre><p>class RandomWords extends StatefulWidget{<br>  @override<br>  State<statefulwidget> createState() {<br>    // TODO: implement createState<br>    return new RandomWordsState();<br>  }<br>}</statefulwidget></p><p>class RandomWordsState extends State<randomwords>{<br>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>  }<br>}</randomwords></p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面将这个widget添加到我们的页面上去，在RandomWordsState的build里面描述要展示的内容。然后把这个widget展示到body里面去，展示的效果不变，代码如下：</code></pre><p>class MyApp extends StatelessWidget{<br>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return new MaterialApp(<br>      title: “demo app”,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(“Welcome to flutter”),<br>        ),<br>        body: new Center(<br>          child: new RandomWords()<br>        ),<br>      ),<br>    );<br>  }<br>}</p><p>class RandomWords extends StatefulWidget{<br>  @override<br>  State<statefulwidget> createState() {<br>    // TODO: implement createState<br>    return new RandomWordsState();<br>  }<br>}</statefulwidget></p><p>class RandomWordsState extends State<randomwords>{<br>  final wordPair = new WordPair.random();<br>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return new Text(wordPair.asPascalCase);<br>  }<br>}</randomwords></p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大部分操作都是在RandomWordsState里面完成的，在这里RandomWords不需要做太多事。## ListView的使用&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;列表在页面布局里面也是很常见的，这里进一步扩展下RandomWordsState类，生成并展示词组列表。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先来定义一个保存推荐词组的数组，还有个字体样式。</code></pre><p>final _suggestions = <wordpair>[];<br>final _fontSize = new TextStyle(fontSize: 16.0);</wordpair></p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;创建一个_buildRow函数，传入参数WordPair，渲染ListView的每一行展示的widget树。</code></pre><p>Widget _buildRow(WordPair pair){<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _fontSize,<br>      ),<br>    );<br>  }</p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;创建一个_buildSuggestions()函数，来构建ListView。ListView提供了一个itemBuilder属性，这是一个工厂build，并作为匿名函数回调。它有两个参数，context上下文和i行迭代器，对应数组里的每一个推荐词都会执行一次函数调用，迭代器从0开始，每调一次就会增加1。在本次示例里我会先添加20个推荐词到数组里面，然后渲染到ListView里面，_buildSuggestions代码如下。</code></pre><p>  Widget _buildSuggestions(){<br>    _suggestions.addAll(generateWordPairs().take(20));<br>    return new ListView.builder(<br>        itemBuilder: (context,i){<br>          return _buildRow(_suggestions[i]);<br>        }<br>    );<br>  }</p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这时候运行一下，发现列表出来了。但是上拉滑动的时候发现问题了，超出20个item之后还可以向下滚动，白屏，如图。&lt;img src=&quot;https://i.imgur.com/FhKPbxr.jpg&quot; width=&quot;40%&quot;/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;出现这种情况是因为ListView的builder构造器运行按需建立延时加载的view。只需要判断下迭代器，超出长度后不渲染view就可以了，代码如下。现在运行就正常了。</code></pre><p>  Widget _buildSuggestions(){<br>    _suggestions.addAll(generateWordPairs().take(20));<br>    return new ListView.builder(<br>        itemBuilder: (context,i){<br>          if(i &lt; _suggestions.length){<br>            return _buildRow(_suggestions[i]);<br>          }<br>        }<br>    );<br>  }</p><pre><code>&lt;img src=&quot;https://i.imgur.com/NBzsr9Y.jpg&quot; width=&quot;40%&quot;/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在我们想给列表每一列加上一条分割线，在这里我们也把分割线当做一个row添加到ListView里面去，一行数据隔一行分割线，具体原来代码里有注释。</code></pre><p>Widget _buildSuggestions(){<br>    _suggestions.addAll(generateWordPairs().take(20));<br>    return new ListView.builder(<br>        itemBuilder: (context,i){<br>          if(i.isOdd){return new Divider();}//如果i是奇数，就添加分割线，如果是偶数，才添加带数据的row<br>          final index = i ~/ 2;//效果和整除差不多，i为0、1、2、3、4、5…，算到的index为0、0、1、1、2、2…<br>          //index的计算，主要是因为插入了分割线以后，迭代器迭代的次数是原来的双倍，一半是渲染分割线，一半是渲染带数据的row<br>          if(index &lt; _suggestions.length){<br>            return _buildRow(_suggestions[index]);<br>          }<br>        }<br>    );<br>  }</p><pre><code>&lt;img src=&quot;https://i.imgur.com/9j1Z7q8.jpg&quot; width=&quot;40%&quot;/&gt;## 交互操作&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里我们为每一行添加一个心型图，类似点赞，可以点赞和取消点赞的效果。首先我建一个Set集合来保存我们点过赞的单词，Set集合不允许重复数据，比List合适。</code></pre><p>final _saved = new Set<wordpair>();</wordpair></p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在每一个row添加心型图，并声明一个aleardySaved判断是否被点赞。</code></pre><p>  Widget _buildRow(WordPair pair){<br>    final aleardySaved = _saved.contains(pair);//判断是否包含当前单词，判断是否被赞<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _fontSize,<br>      ),<br>      trailing: new Icon(<br>        aleardySaved ? Icons.favorite : Icons.favorite_border,<br>        color: aleardySaved ? Colors.red:null,<br>      ),<br>    );<br>  }</p><pre><code>&lt;img src=&quot;https://i.imgur.com/znQsbFL.jpg&quot; width=&quot;40%&quot;/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此时点击还没有任何效果，还需要给每个row添加点击事件。</code></pre><p>  Widget _buildRow(WordPair pair){<br>    final aleardySaved = _saved.contains(pair);//判断是否包含当前单词，判断是否被赞<br>    return new ListTile(<br>      title: new Text(<br>        pair.asPascalCase,<br>        style: _fontSize,<br>      ),<br>      trailing: new Icon(<br>        aleardySaved ? Icons.favorite : Icons.favorite_border,<br>        color: aleardySaved ? Colors.red:null,<br>      ),<br>      onTap: () =&gt; _favourite(pair),<br>    );<br>  }</p><p>  void _favourite(WordPair pair){<br>    setState((){<br>      if(_saved.contains(pair)){<br>        _saved.remove(pair);<br>      }else{<br>        _saved.add(pair);<br>      }<br>    });<br>  }</p><pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在就达到我们要的效果，点击变红色并保存，再次点击变成默认的，并从set集合移除。&lt;img src=&quot;https://i.imgur.com/WtOzJYH.jpg&quot; width=&quot;40%;&quot;/&gt;## 跳转到新页面&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在页面导航栏加一个按钮，跳转到新的页面，Navigator管理着包含了应用程序所有路由的堆栈，将一个路由push到堆栈，将显示更新到新的页面路由，将一个路由pull出堆栈，将返回显示前一个页面路由。</code></pre><pre><code>return new Scaffold(    appBar: new AppBar(      title: new Text(&quot;Welcome to flutter&quot;),      actions: &lt;Widget&gt;[new IconButton(icon: new Icon(Icons.list), onPressed: _pushNavi)],    ),    body:  _buildSuggestions());</code></pre><pre><code></code></pre><p>void _pushNavi(){<br>    Navigator.of(context).push(<br>        new MaterialPageRoute(<br>            builder:(context){<br>              return new Scaffold(<br>                appBar: new AppBar(<br>                  title: new Text(“Welcome to new page”),<br>                ),<br>                body: new Center(<br>                  child: new Text(“new page”),<br>                ),<br>              );<br>            })<br>    );<br>  }<br>```<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;效果如下：<br><img src="https://i.imgur.com/AWWSGHY.jpg" width="40%;"><br><img src="https://i.imgur.com/Ny0kMrV.jpg" width="40%;"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Flutter初识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter开发环境配置</title>
      <link href="/2018/03/18/flutter-kai-fa-huan-jing-pei-zhi/"/>
      <url>/2018/03/18/flutter-kai-fa-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/bXtQMgo.jpg" width="100%"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“工欲善其事，必先利其器。”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;————论语·魏灵公<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个好的工具，将可以使之后的工作事半功倍。我们学习每一门新的开发语言，必然先做初步的了解，然后着手准备工具，也就是配置安装开发环境。本文我们来看看Flutter对配置的要求，以及如何配置开发环境（基于Windows）。<br><a id="more"></a></p><h3 id="对系统的要求"><a href="#对系统的要求" class="headerlink" title="对系统的要求"></a>对系统的要求</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要安装并运行 Flutter ，你的开发环境必须满足这些最低要求：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>操作系统：</strong>Windows 7 或者更高版本（64 位）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>磁盘空间：</strong>400 MB（不包括 Android Studio 在内的磁盘空间）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>工具：</strong> Flutter 依赖了你环境中可用的命令行工具（从 Windows 命令提示符选项中使用 Git）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，Android Studio和git是需要下载的。首先我们来下载git,地址：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git for windows</a>。如果已经安装了，可以在windows下的cmd命令里输入git命令验证下是否已安装。  </p><h3 id="获取Flutter-SDK"><a href="#获取Flutter-SDK" class="headerlink" title="获取Flutter SDK"></a>获取Flutter SDK</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了能够调用到Flutter的Sdk，需要用git去克隆仓库到本地，然后将Flutter库添加到环境变量。</p><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次安装时需要运行克隆仓库命令：</p><pre><code>$ git clone -b beta https://github.com/flutter/flutter.git</code></pre><h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了让应用可以调用到Flutter仓库，需要将它添加到环境变量:右击“计算机”-&gt;“属性”-&gt;“高级系统设置”-&gt;“环境变量”。在用户环境变量中找到path变量，在末尾加上Flutter的全路径“..\flutter\bin;”，然后重启下电脑。</p><h4 id="运行flutter-doctor"><a href="#运行flutter-doctor" class="headerlink" title="运行flutter doctor"></a>运行flutter doctor</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令行运行以下命令，看是否需要安装任何依赖来完成安装。</p><pre><code>$ flutter doctor</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该命令会检测环境和终端窗口生成报告，第一次运行这个命令的时候会下载自己的依赖库并编译，可能会有点慢，以后再次运行就会很快了。Datr SDK和Flutter捆绑在一起，不需要单独下载。（<strong><em>注意：该命令需要在系统命令行管理员权限下执行，在flutter的bin目录下执行，否则可能报错：没有权限/失败等。文件路径纯英文。</em></strong>）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时候会出现链接失败，如图。会自动重连，可能等一会就能连上。<br><img src="https://i.imgur.com/mvCUIyA.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行完成之后如下。红框中X字开头的都是还缺少的依赖，此时在执行如下命令就可以加载了。</p><pre><code>$ flutter</code></pre><p><img src="https://i.imgur.com/BUXshQL.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我这里开发工具用的Android Studio,这些报的缺失的依赖是在IntelliJ下面的，所以可以不去管它，如果需要添加依赖，只需要在IntelliJ的“File-&gt;Settings-&gt;Plugins”下面点击“Browse repositories…”，然后搜索“Flutter”加载插件，重启就可以了。Datr是和Flutter一起的，install了Flutter之后Dart插件也有了。<br><img src="https://i.imgur.com/j6cw9g7.png" alt=""><br><img src="https://i.imgur.com/u6883JZ.png" alt=""></p><h3 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置好之后，在Android Studio中创建一个Flutter项目，“File-&gt;New-&gt;New Flutter Project…”，输入项目名称，点“NEXT”直到完成，项目创建好了之后如果有相关的提示需要update就点更新下。<br><img src="https://i.imgur.com/6hOvKh6.png" alt=""><br><img src="https://i.imgur.com/0fklRFK.png" alt=""><br><img src="https://i.imgur.com/JRiDewn.png" alt=""></p><h3 id="小坑记"><a href="#小坑记" class="headerlink" title="小坑记"></a>小坑记</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有个小插曲，分享下，要是有朋友遇到也好解决。我在创建好项目之后，点击运行，总是报一个错，如下图。<br><img src="https://i.imgur.com/7PZl1Hr.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照提示，执行了“flutter doctor –android-licenses”之后，也会报错，只有在android sdk目录下的licenses目录下执行才不会报错，但是也没有什么效果。后来仔细查了一下，发现android sdk目录下，build-tools目录的最后一个版本是26.0.2，platforms目录的最后一个版本是android-27，不是一个版本，可能没有对应的开源许可证号可用，于是将build-tools更新到27.xx.xx。然后运行项目还是报错，同样问题，删掉项目，重新建一个，运行就好了。可能问题比较低级，有时候脑子转不过来就一时难以发现o(╥﹏╥)o。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后运行成功，界面如下。<br><img src="https://i.imgur.com/cuWZtAw.jpg" width="40%"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Flutter初识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter初识</title>
      <link href="/2018/03/06/flutter-chu-shi/"/>
      <url>/2018/03/06/flutter-chu-shi/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;偶然在大神的公众号上看到一篇文章<a href="https://mp.weixin.qq.com/s/OPbTg_wtFEP7hQ9ADX5L7Q" target="_blank" rel="noopener">Google 跨平台 UI 框架 - Flutter</a>，介绍了google推出的一门新的跨平台移动框架，引发了我的兴趣，决定跟踪学习研究下。先来对这套框架做一个初步的了解。<br><a id="more"></a><br>官网地址：<a href="https://doc.flutter-dev.cn/" target="_blank" rel="noopener">中文网</a>、<a href="https://flutter.io/" target="_blank" rel="noopener">英文网</a></p><h2 id="Flutter是什么"><a href="#Flutter是什么" class="headerlink" title="Flutter是什么"></a>Flutter是什么</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flutter是google推出的一款移动端UI框架，可以快速地构建IOS和Android平台上高质量的原生级界面。Flutter可以和已有代码一起使用，是一套免费的开源框架。</p><h3 id="支持热更新"><a href="#支持热更新" class="headerlink" title="支持热更新"></a>支持热更新</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flutter支持的热更新可以让用户快速构建UI、添加功能以及修复BUG，在Android和IOS的模拟器以及真机上可以体验到亚秒级重载，不会造成状态的丢失。<br><img src="https://i.imgur.com/VAb7Lty.gif" alt=""></p><h3 id="丰富的UI"><a href="#丰富的UI" class="headerlink" title="丰富的UI"></a>丰富的UI</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flutter内置了目前Android比较流行的Material Design和IOS的Cupertino风格的库，可以快速构建出美观时尚的UI界面。丰富的手势API，平滑的滑动等带来良好的用户体验。<br><img src="https://i.imgur.com/02fHRCw.png" alt=""></p><h3 id="响应式框架"><a href="#响应式框架" class="headerlink" title="响应式框架"></a>响应式框架</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flutter使用了时尚的响应式框架，丰富的平台、布局以及基础组件，为用户提供了强大而灵活的API，解决了复杂的用户界面构建。</p><pre><code>class CounterState extends State&lt;Counter&gt; {  int counter = 0;  void increment() {    // Tells the Flutter framework that state has changed,    // so the framework can run build() and update the display.    setState(() {      counter++;    });  }  Widget build(BuildContext context) {    // This method is rerun every time setState is called.    // The Flutter framework has been optimized to make rerunning    // build methods fast, so that you can just rebuild anything that    // needs updating rather than having to individually change    // instances of widgets.    return new Row(      children: &lt;Widget&gt;[        new RaisedButton(          onPressed: increment,          child: new Text(&#39;Increment&#39;),        ),        new Text(&#39;Count: $counter&#39;),      ],    );  }}</code></pre><h3 id="兼容平台原生功能以及SDK"><a href="#兼容平台原生功能以及SDK" class="headerlink" title="兼容平台原生功能以及SDK"></a>兼容平台原生功能以及SDK</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平台API、第三方SDK以及native code让你的代码更具有可扩展性。Flutter允许继续使用现有的java、swift、obj-c代码，并可以访问Android和IOS的native功能以及SDK。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来看一段访问native code的代码示例：</p><pre><code>Future&lt;Null&gt; getBatteryLevel() async {  var batteryLevel = &#39;unknown&#39;;  try {    int result = await methodChannel.invokeMethod(&#39;getBatteryLevel&#39;);    batteryLevel = &#39;Battery level: $result%&#39;;  } on PlatformException {    batteryLevel = &#39;Failed to get battery level.&#39;;  }  setState(() {    _batteryLevel = batteryLevel;  });}</code></pre><h3 id="跨平台统一的开发"><a href="#跨平台统一的开发" class="headerlink" title="跨平台统一的开发"></a>跨平台统一的开发</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flutter工具和库可以轻松把你的想法带到Android和IOS设备上，如果你还未接触过移动开发，Flutter是你很好的选择；如果你是一位经验丰富的移动开发者，Flutter可以为你的移动应用的构建完美的界面，并且可以充分利用已有的java、swif、obj-c代码。<br><img src="https://i.imgur.com/skTot2F.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Flutter初识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio模板</title>
      <link href="/2018/02/28/android-zi-ding-yi-gong-cheng-mo-ban/"/>
      <url>/2018/02/28/android-zi-ding-yi-gong-cheng-mo-ban/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/kpfqJDI.jpg" width="100%"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“Stop Trying to Reinvent the Wheel”,不要重复造轮子，每个程序员入行就会被告知这条准则。技术更新非常快，我们需要不停地学习，不要把时间浪费在重复劳动上面。虽说未必能达到造轮子的水准，但是制作一些模板，尽可能地避免重复工作还是非常必要的。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常工作中，使用模板，将会使我们的工作事半功倍，极大地提高工作效率。Google为了方便开发者，在Android Studio内置了三种模板，我们来了解下。  </p><table><thead><tr><th style="text-align:center">模板</th><th style="text-align:center">作用范围</th><th style="text-align:center">配置路径</th></tr></thead><tbody><tr><td style="text-align:center">Live templates</td><td style="text-align:center">代码块</td><td style="text-align:center">Settings-&gt;Editor-&gt;Live Templates</td></tr><tr><td style="text-align:center">File templates</td><td style="text-align:center">单文件创建</td><td style="text-align:center">Settings-&gt;Editor-&gt;File and Code Templates</td></tr><tr><td style="text-align:center">Plugins templates</td><td style="text-align:center">多文件创建</td><td style="text-align:center">AS安装目录\plugins\android\lib\templates\activities</td></tr></tbody></table><h3 id="Live-templates"><a href="#Live-templates" class="headerlink" title="Live templates"></a>Live templates</h3><p><img src="https://i.imgur.com/KRLnQCD.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们进入Android Studio中Live Templates对应的设置页。这里有Google为了方便开发者默认设置好的很多的Template Group，每个Group里面有很多的Tamplate，这里以Android这个Group为例。<br><img src="https://i.imgur.com/xwOm1MF.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到名为Android的Template Group下面有很多的Live Template。鼠标选中第一个，看到界面如下：<br><img src="https://i.imgur.com/pwRDlMq.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在“Abbreviation”输入框处为Template指定名字，在“Template text”输入需要简化的语句或者代码块，并且点击底部的“Applicate in ..”指定适用的文件类型和语句块。在语句中使用“$…$”表示待输入的变量，每次输入的时候，相同的变量会一起改变，比如语句中有两个变量“$count$”，则给前一个变量赋值的时候，后面一个变量的值也会随之改变。<br><img src="https://i.imgur.com/7qTrxkt.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用“Edit variables”对创建的Live Template进行一些特殊修改。<br><img src="https://i.imgur.com/vvg5GVW.png" alt=""></p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Expression</th><th style="text-align:center">Default value</th><th style="text-align:center">Skip if defined</th></tr></thead><tbody><tr><td style="text-align:center">定义在$..$中的变量名</td><td style="text-align:center">赋予变量特殊值</td><td style="text-align:center">默认值</td><td style="text-align:center">使用时是否跳过编辑</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression里面有很多函数，例如className()、date()、methodName()等等。“Skip if defined”不勾选，光标就停在变量处；如果勾选了，光标就会移动到生成的语句或者代码块末尾。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置好Live template，在代码中输入对应的key就会得到相应的提示，敲下Enter或者Tab就可以输出对应的语句或者代码块。<br><img src="https://i.imgur.com/kU7nftl.gif" alt="">  </p><blockquote><p>设置位置：Settings-&gt;Editor-&gt;Live Templates<br>作用：简化一些常用的语句、常用的代码块</p></blockquote><h3 id="File-templates"><a href="#File-templates" class="headerlink" title="File templates"></a>File templates</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建文件的时候，Android Studio提供了一些模板，如java、Singleton等，在创建后就自动生成模板的代码，一般用于单文件级别的代码模板。注释可以引用header来修改，也可以整个模板写进去。<br><img src="https://i.imgur.com/QlUDMEa.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入到Android Studio的File templates设置页，这里的“Files”标签页对应的是文件模板，“Includes”标签页是定义的一些header之类的引用模板，“Code”和“Other”标签下面的代码模板是不可以新建和删除的，只能对默认生成的文件进行修改。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在android项目中大家最常用的是列表，这里以RecyclerView适配器代码为例创建一个模板。首先点击“+”新建一个名叫“RecyclerViewAdapter”的File。<br><img src="https://i.imgur.com/nviuJGb.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加模板代码</p><pre><code>#if (${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#endimport android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;#parse(&quot;File Header.java&quot;)public class ${FILE_NAME} extends RecyclerView.Adapter&lt;${FILE_NAME}.${VIEW_HOLDER_NAME}&gt; #if (${INTERFACES} != &quot;&quot;)implements ${INTERFACES} #end {    private Context mContext;    private LayoutInflater mLayoutInflater = null;    public ${FILE_NAME}(Context context) {        mContext = context;        mLayoutInflater = LayoutInflater.from(mContext);    }    @Override    public ${VIEW_HOLDER_NAME} onCreateViewHolder(ViewGroup parent, int viewType) {        return null;    }    @Override    public void onBindViewHolder(${VIEW_HOLDER_NAME} holder, int position) {    }    @Override    public int getItemCount() {        return 0;    }    static class ${VIEW_HOLDER_NAME} extends RecyclerView.ViewHolder{        public ${VIEW_HOLDER_NAME}(View itemView) {            super(itemView);        }    }}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存好模板后，我们在New下面就可以找到对应的模板，输入对应变量之后就可以直接生成我们所需要的文件。<br><img src="https://i.imgur.com/8l8PqDp.gif" alt=""></p><blockquote><p>设置位置：Settings-&gt;Editor-&gt;File and Code Templates<br>作用：使用单文件创建，只能处理当前文件</p></blockquote><h3 id="Plugins-templates"><a href="#Plugins-templates" class="headerlink" title="Plugins templates"></a>Plugins templates</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是本文的重点，很牛的模板。在创建Activity的时候选择对应的模板，Android Studio会同时将activity配置到主配置文件里面去。这个模板的强大在于创建文件的同时可以处理多个文件，只是定义起来相对复杂一些，下面我们结合Android Studio默认自带的一些模板，来分析一模板下结构。打开Android Studio的安装目录，找到目录“androidstudio\plugins\android\lib\templates\activities”下，我们可以看到自带得模板。<br><img src="https://i.imgur.com/soTTtu3.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找一个最常用的模板来深入分析一下。选择打开“EmptyActivity”模板文件夹，看到结构。<br><img src="https://i.imgur.com/TQMqArX.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xx.png是标图。剩下两个ftl文件、一个xml文件和一个root文件夹，这里xml文件我们时候用过的，可能ftl文件相对陌生，不过写法也很简单，不难理解，下面我们先来分析下这几个文件。</p><h4 id="1、globals-xml-ftl"><a href="#1、globals-xml-ftl" class="headerlink" title="1、globals.xml.ftl"></a>1、globals.xml.ftl</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看文件名大概能猜到，这里定义的是全局的，里面定义了全局变量，引用了common下的全局变量，来看下代码：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;globals&gt;    &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;    &lt;global id=&quot;parentActivityClass&quot; value=&quot;&quot; /&gt;    &lt;global id=&quot;simpleLayoutName&quot; value=&quot;${layoutName}&quot; /&gt;    &lt;global id=&quot;excludeMenu&quot; type=&quot;boolean&quot; value=&quot;true&quot; /&gt;    &lt;global id=&quot;generateActivityTitle&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;    &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;&lt;/globals&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 开发环境和配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android项目结构</title>
      <link href="/2018/02/27/android-xiang-mu-jie-gou/"/>
      <url>/2018/02/27/android-xiang-mu-jie-gou/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/dtFmRqb.jpg" width="100%"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍Android studio工具里android工程的目录结构，各包、文档的作用，以及对比和Eclipse下android的工程目录结构的不同之处。<br><a id="more"></a></p><h2 id="不同IDE下android工程结构的对比"><a href="#不同IDE下android工程结构的对比" class="headerlink" title="不同IDE下android工程结构的对比"></a>不同IDE下android工程结构的对比</h2><h3 id="1、Eclipse下目录结构"><a href="#1、Eclipse下目录结构" class="headerlink" title="1、Eclipse下目录结构"></a>1、Eclipse下目录结构</h3><p><img src="https://i.imgur.com/l0VhnxL.png" alt=""><br> <strong>src</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里存放的是java代码。<br> <strong>gen</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里存放R.java文件，该文件自动标识了资源的索引。<br> <strong>Android 4.4W</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4W是android平台版本，对应于API 20，该文件里面包含了android.jar文件，里面关联了Android的API。<br> <strong>Android Private Libraries</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里存放的是libs目录下jar包的映射，libs里的jar包引用视为私有引用，也就是第三方的库。添加jar包到libs里面会自动添加引用到Android Private Libraries里面，移除libs目录的jar包，这里的引用也会自动移除。<br> <strong>JRE System Library</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应于JDK安装后的jre目录核心类库，表示系统类库文件，这里存放的jar包是java运行依赖的类库。<br> <strong>Android Dependencies</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件包含了工程引用的library。<br> <strong>assets</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放置原生文件，里面的文件会保留原有格式，文件袋额读取需要通过流。<br> <strong>bin</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放置工程编译后生成的文件，以及apk安装包。<br> <strong>libs</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放置引用的第三方库类文件。<br> <strong>res</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目的资源文件，里面按文件夹分类存放图片、布局等资源文件，会在R.java文件中自动生成索引。<br> <strong>AndroidManifest.xml</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;android工程的主配置清单文件，配置了应用的基本信息，应用名称、icon、包名、版本、权限、组件、应用程序入口等，应用启动前先访问主配置清单文件。<br> <strong>proguard-project.txt 和 project.properties</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码混淆文件。  </p><h3 id="2、Android-Studio下目录结构"><a href="#2、Android-Studio下目录结构" class="headerlink" title="2、Android Studio下目录结构"></a>2、Android Studio下目录结构</h3><p><img src="https://i.imgur.com/RbEOaYY.png" alt=""><br> <strong>.gradle</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gradle运行构建时自动生成的文件，不需要更改，也不需要纳入源码管理。<br> <strong>.idea</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IDE运行时自动生成的文件，不需要更改，也不需要纳入源码管理。<br> <strong>app</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个module，每一个module都类似于Eclipse里面的一个Project，module结构和父项目结构类似。<br><img src="https://i.imgur.com/ke2lT2n.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>build</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译时自动输出的文件，不需要更改，也不需要纳入源码管理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>libs</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app模块引用的第三方类库文件，需要的第三方jar文件放这里，.so文件也放这里。可以在Project Structure中管理它的依赖关系，也可以在build.gradle中直接修改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>src</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module源码所在目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>androidTest</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Android Studio生成的测试模块，可删。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>main</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module源码目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>test</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元测试模块，可删。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>.gitignore</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module中git管理源码的配置文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>app.iml</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module中IDE生成的文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>build.gradle</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module自动编译的配置文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>proguard-rules.pro</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module中代码混淆配置文件。<br> <strong>build</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译时自动输出的文件，不需要更改，也不需要纳入源码管理。<br> <strong>gradle</strong><br><img src="https://i.imgur.com/nbLeTek.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gradle目录下有个wrapper目录，里面有两个文件，里面是对gradle的配置信息。来看下gradle-wrapper.properties里面的内容：  </p><pre><code>distributionBase=GRADLE_USER_HOME  distributionPath=wrapper/dists  zipStoreBase=GRADLE_USER_HOME  zipStorePath=wrapper/dists  distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</code></pre><p>可以看到里面声明了gradle的目录、下载路径、版本等信息。<br> <strong>.gitignore</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git对源码管理的配置文件，可以在里面添加你不希望纳入源码管理的文件。<br> <strong>build.gradle</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目的编译环境配置文件，gradle最主要的配置文件，这里是对整个project的配置，代码如下：</p><pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript {    repositories {        google()        jcenter()    }    dependencies {        classpath &#39;com.android.tools.build:gradle:3.0.1&#39;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }}allprojects {    repositories {        google()        jcenter()    }}task clean(type: Delete) {    delete rootProject.buildDir}</code></pre><p>这里声明了仓库源，google()，还有个新的jcenter()，jcenter()可以理解成远程仓库，它兼容了maven中心仓库，性能更优；还声明了gradle的版本。<br> <strong>gradle.properties</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置gradle运行环境的文件，配置gradle运行时的模式、运行时JVM虚拟机的大小等。<br> <strong>gradlew 和 gradlew.bat</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者是linux下的shell脚本，后者是windows下的批处理命令，它们的作用是根据gradle-wrapper.properties文件中的distributionUrl下载对应版本的gradle。这样可以保证在不同的环境下构建都是用的统一的gradle版本，即使没有安装gradle，也会自动下载对应版本的gradle。<br> <strong>local.properties</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置android NDK、SDK的地方，一般不纳入源码管理。<br> <strong>settings.gradle</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明当前项目包含哪些module，如果多个module，中间用“,”分开，代码如下：</p><blockquote><p>include ‘:app1’,’:app2’</p></blockquote><p> <strong>ProjectName.iml</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译项目时自动生成的文件，文件名一般为“项目名.iml”，是Android Studio识别项目的配置文件，不纳入源码管理。  </p><h3 id="3、Android-Studio相比Eclipse的优势"><a href="#3、Android-Studio相比Eclipse的优势" class="headerlink" title="3、Android Studio相比Eclipse的优势"></a>3、Android Studio相比Eclipse的优势</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前Android Studio已经更新到了3.0.1的版本，相对已经比较稳定了，功能也非常强大。2015年Android Studio1.0发布的时候，google就宣布停止对Eclipse的支持，新的API、插件不会考虑Eclipse的支持，所以想要开发Android的童鞋，Android Studio成了首选的工具，而且Android Studio的功能确实也非常强大，相对于Eclipse更加智能，体现在如下几点：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Android studio由google推出，指定的官方工具，后期google工程师肯定会不断完善完美融合Android；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Eclipse响应慢，内存溢出问题一直让人诟病，Android Studio经过几个版本的迭代，已经非常的稳定流畅，体验非常的棒；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、更加智能。代码补全更智能，输入时，Android Studio会自动智能预测输入并给出最优提示；自动保存，无需经常Ctrl+C；智能重构、智能预测报错；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、整合了Gradle构建工具。Android Studio的一大亮点就是使用Gradle构建，gradle结合了Ant和Maven的有点，不管是配置、编译、打包都非常的方便；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、更强大智能的UI编辑器。Android Studio的UI编辑器非常强大智能，吸收了Eclipse+ADT的优点，还自带多屏布局预览，颜色、图片、string可以在布局和代码中可以实时预览；截图带有设备框，可以随时录制模拟器的视频，非常方便；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、内置终端。不需要再打开CMD命令，来回切换界面了，直接在Terminal终端就可以执行命令；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7、更完善的插件系统，支持各种插件，Git、Markdown、Gradle等；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8、完美整合版本控制，安装时自带Git、Github、SVN等版本控制系统，可以方便的管理代码；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9、可以直接打开文件所在位置。即使文件关闭，重新打开依然可以回退操作。图片可以直接转.9图片，自带.9编辑。在gradle编译时使用aar依赖超级方便；  </p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 开发环境和配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android开发环境搭建及配置</title>
      <link href="/2018/02/27/android-kai-fa-huan-jing-da-jian-ji-pei-zhi/"/>
      <url>/2018/02/27/android-kai-fa-huan-jing-da-jian-ji-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/cQyeK8i.jpg" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="学而不思则罔，思而不学则殆。"><a href="#学而不思则罔，思而不学则殆。" class="headerlink" title="学而不思则罔，思而不学则殆。"></a>学而不思则罔，思而不学则殆。</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ————孔子<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次学习知识都有种茫然无措、丢三落四的感觉，看到那么多的大牛整理的技术栈，我觉得是很有帮助的。从这篇文章开始整理自己的知识体系，以后学习起来有方向有目标，也方便回顾、方便把知识串联起来。加油ヾ(◍°∇°◍)ﾉﾞ！<br><a id="more"></a></p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们使用的开发工具选择android studio，首先我们需要下载好JDK和android studio，下载地址如下：<br>JDK：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>android studio：<a href="http://www.android-studio.org/" target="_blank" rel="noopener">http://www.android-studio.org/</a>  </p><h3 id="1、JDK下载"><a href="#1、JDK下载" class="headerlink" title="1、JDK下载"></a>1、JDK下载</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击上面的JDK下载地址，进入oracle网站，在①处选中同意条款，然后根据对应的系统，选在下载哪个jdk。<br><img src="https://i.imgur.com/d56zIeC.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载完成后双击应用程序安装。<br><img src="https://i.imgur.com/9JO3uCH.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点“下一步”<br><img src="https://i.imgur.com/MZGZQUA.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置安装路径，点击“下一步”<br><img src="https://i.imgur.com/9uRa7M2.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后等待安装完成就可以了，到这里，JDK我们就安装完成了。  </p><h3 id="2、配置环境变量"><a href="#2、配置环境变量" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标右击桌面上的“计算机”，点击“属性”，进入如下界面，然后点击“高级系统设置”。<br><img src="https://i.imgur.com/2xLM2ca.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击“环境变量”。<br><img src="https://i.imgur.com/VgoY3uF.png" alt=""><br>在“系统环境变量”里面找到如下三个环境变量，加入对应的值；如果找不到环境变量，就新建一个。 </p><blockquote><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">CLASSPATH</td><td style="text-align:left">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</td></tr><tr><td style="text-align:left">JAVA_HOME</td><td style="text-align:left">D:\idesignApplication\jdk\jdk1.7</td></tr><tr><td style="text-align:left">Path</td><td style="text-align:left">;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</td></tr></tbody></table></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后我们打开cmd命令行，校验一下配置是否正确，命令行输入“java -version”，终端输出如下，说明配置无误。<br><img src="https://i.imgur.com/Pm5Es1k.png" alt="">  </p><h3 id="3、Android-studio下载安装"><a href="#3、Android-studio下载安装" class="headerlink" title="3、Android studio下载安装"></a>3、Android studio下载安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开上面给出的android studio下载地址，这里我们在安卓中文社区下载的，更新没有google官方快，但是省去翻墙，也不会晚太多，可以在国内下载使用。<br><img src="https://i.imgur.com/a7omQ3R.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择对应的平台版本下载下来，双击安装，一路点击“Next”可以安装完成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里要注意，在第一次打开的时候可能会报一个错误“Unable to access Android SDK”，如下图。<br><img src="https://i.imgur.com/b1eT8HX.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为加载不到SDK的原因，这里我们直接点“Cancel”，继续后面的步骤，进去以后再加载SDK就可以了。  </p><h3 id="4、加载SDK"><a href="#4、加载SDK" class="headerlink" title="4、加载SDK"></a>4、加载SDK</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成进入android studio之后，在工具栏找到SDK Manager，点击进去，选择加载SDK。<br><img src="https://i.imgur.com/ngF0TcZ.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入SDK Manager之后，界面如下：<br><img src="https://i.imgur.com/1K1TonA.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在SDK Platforms标签下，可以看到各个版本的SDK库，选中右下角的“show Package Details”，可以看到更详细的分类，这里勾选需要的版本，点击右下角“Apply”按钮下载。下载完成之后，点击切换到SDK Tools的标签下面，找到“Android SDK Build-Tools”，选在对应的版本下载下来。<br><img src="https://i.imgur.com/itkiqFM.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此我们就完成了Android开发工具以及环境的最基本的配置。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 开发环境和配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android历史版本介绍</title>
      <link href="/2018/02/26/li-shi-ban-ben-jie-shao/"/>
      <url>/2018/02/26/li-shi-ban-ben-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Android历史版本介绍。<br><a id="more"></a></p><table><thead><tr><th style="text-align:center">API Level</th><th style="text-align:center">版本号</th><th style="text-align:center">代号(甜点)</th><th style="text-align:center">发布日期</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">Android 1.0 Beta</td><td style="text-align:center">-</td><td style="text-align:center">2007年11月5日</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Android 1.0</td><td style="text-align:center">-</td><td style="text-align:center">2008年9月23日</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Android 1.1</td><td style="text-align:center">Petit Four</td><td style="text-align:center">2009年2月2日</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Android 1.5</td><td style="text-align:center">Cupcake(纸杯蛋糕)</td><td style="text-align:center">2009年4月30日</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Android 1.6</td><td style="text-align:center">Donut(甜甜圈)</td><td style="text-align:center">2009年9月15日</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Android 2.0</td><td style="text-align:center">Éclair(闪电泡芙、法式奶油夹心甜点、松饼)</td><td style="text-align:center">2009年10月26日</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Android 2.0.1</td><td style="text-align:center">Éclair(闪电泡芙、法式奶油夹心甜点、松饼)</td><td style="text-align:center">2009年12月3日</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">Android 2.1</td><td style="text-align:center">Éclair(闪电泡芙、法式奶油夹心甜点、松饼)</td><td style="text-align:center">2010年1月12日</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Android 2.2</td><td style="text-align:center">Froyo(冻酸奶)</td><td style="text-align:center">2010年5月20日</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Android 2.3</td><td style="text-align:center">Gingerbread(姜饼)</td><td style="text-align:center">2010年12月7日</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Android 2.3.3</td><td style="text-align:center">Gingerbread(姜饼)</td><td style="text-align:center">2011年2月9日</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Android 3.0</td><td style="text-align:center">Honeycomb(蜂巢)</td><td style="text-align:center">2011年2月24日</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">Android 3.1</td><td style="text-align:center">Honeycomb(蜂巢)</td><td style="text-align:center">2011年5月10日</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">Android 3.2</td><td style="text-align:center">Honeycomb(蜂巢)</td><td style="text-align:center">2011年7月15日</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">Android 4.0</td><td style="text-align:center">Ice Cream Sandwich(雪糕三明治)</td><td style="text-align:center">2011年10月19日</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">Android 4.0.3</td><td style="text-align:center">Ice Cream Sandwich(雪糕三明治)</td><td style="text-align:center">2011年12月16日</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">Android 4.1</td><td style="text-align:center">Jelly Bean(果冻豆)</td><td style="text-align:center">2012年6月28日</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">Android 4.2</td><td style="text-align:center">Jelly Bean(果冻豆)</td><td style="text-align:center">2012年10月30日</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">Android 4.3</td><td style="text-align:center">Jelly Bean(果冻豆)</td><td style="text-align:center">2013年7月24日</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">Android 4.4</td><td style="text-align:center">KitKat(奇巧巧克力棒)</td><td style="text-align:center">2013年10月31日</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">Android 4.4W</td><td style="text-align:center">KITKAT_WATCH</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">Android 5.0</td><td style="text-align:center">Lollipop(棒棒糖)</td><td style="text-align:center">2014年6月25日</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">Android 5.1</td><td style="text-align:center">Lollipop(棒棒糖)</td><td style="text-align:center">2015年3月10日</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">Android 6.0</td><td style="text-align:center">Marshmallow(棉花糖)</td><td style="text-align:center">2015年5月28日</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">Android 7.0</td><td style="text-align:center">Nougat(牛轧糖)</td><td style="text-align:center">2016年5月18日</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">Android 7.1</td><td style="text-align:center">Nougat(牛轧糖)</td><td style="text-align:center">2016年12月5日</td></tr><tr><td style="text-align:center">26</td><td style="text-align:center">Android 8.0</td><td style="text-align:center">Oreo(奥利奥)</td><td style="text-align:center">2017年3月21日</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">Android 9.0</td><td style="text-align:center">Pistachio Ice Cream(开心果冰淇淋)</td><td style="text-align:center">2018年5月9日</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 历史版本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年1月15日微信公开课pro概要</title>
      <link href="/2018/01/16/2018-nian-1-yue-15-ri-wei-xin-gong-kai-ke-pro-zhang-xiao-long-yan-jiang-gai-yao/"/>
      <url>/2018/01/16/2018-nian-1-yue-15-ri-wei-xin-gong-kai-ke-pro-zhang-xiao-long-yan-jiang-gai-yao/</url>
      
        <content type="html"><![CDATA[<h2 id="1，微信很克制，利益的堆砌会失去产品最本质的东西"><a href="#1，微信很克制，利益的堆砌会失去产品最本质的东西" class="headerlink" title="1，微信很克制，利益的堆砌会失去产品最本质的东西"></a>1，微信很克制，利益的堆砌会失去产品最本质的东西</h2><p>微信就是一个工具，我们想做最好的工具。微信对功能的取舍需要理性地判断对错，如果只从利益角度出发，可能会让我们的产品越走越偏，变成它里面知识一些利益的堆砌，这样我认为会失去产品更本质的东西。<br><a id="more"></a></p><h2 id="2，不会查看用户的聊天记录"><a href="#2，不会查看用户的聊天记录" class="headerlink" title="2，不会查看用户的聊天记录"></a>2，不会查看用户的聊天记录</h2><p>对微信来说，尊重用户、尊重个人是最本质的东西。我们把用户当朋友，给用户提供最好的产品和服务，也不会去看用户的聊天记录。我们不发任何系统推送，不去做任何诱导行为，也不允许第三方做任何诱导行为，把用户当朋友，而不是当做一个听从我们驱使的群体。  </p><h2 id="3，去中心化"><a href="#3，去中心化" class="headerlink" title="3，去中心化"></a>3，去中心化</h2><p>微信作为一个具有平台属性的工具，一直坚持“去中心化”的观念。微信里面提供了很多的服务，这些服务也是由不同公司来提供，微信只是一个提供服务的地方，并且微信不给这些服务提供一个特别中心化的流量，而是由用的户自己去发现。<br>微信一直致力于遵循这样一个原则，我们不应该去影响各个服务的存在，我们尽可能的让更有价值的服务自己浮现出来被用户找到，而不是我们去左右。在微信里，系统不会推荐用户去订阅一个公众号，对于小程序、小游戏也一样，把选择的权利交给用户。  </p><h2 id="4，公众号App很快会推出"><a href="#4，公众号App很快会推出" class="headerlink" title="4，公众号App很快会推出"></a>4，公众号App很快会推出</h2><p>我们是在做这样一个App，一直没有发布，因为我觉得它还没有完全达到我们的预期。<br>微信是为手机而生，对于PC我们一直很慎重，故意不去做重它，PC版本只是一个输入的地方而已；但是对于公众平台的管理平台，我们把它做成了PC端平台，所以我们认为很早以前就应该要出这样的手机端了。现在这个App我们已经做得差不多了，很快会发布出来。  </p><h2 id="5，公众号赞赏很快会回来"><a href="#5，公众号赞赏很快会回来" class="headerlink" title="5，公众号赞赏很快会回来"></a>5，公众号赞赏很快会回来</h2><p>红包和赞赏这样的行为比较具有中国特色，像苹果这样的公司可能很难理解，后来经过协调，大家达成了共识，“赞赏”功能很快会回来，并且做了一些更改，新版本的赞赏不是针对一个公众号，而是针对作者。结合即将推出的公众号App，用户可以在手机上做创作。  </p><h2 id="6，订阅号不会做信息流"><a href="#6，订阅号不会做信息流" class="headerlink" title="6，订阅号不会做信息流"></a>6，订阅号不会做信息流</h2><p>订阅号本身是用户自己订阅的信息，我们只会去改善阅读的效率，不会胡乱变成不受掌控的信息。  </p><h2 id="7，小程序"><a href="#7，小程序" class="headerlink" title="7，小程序"></a>7，小程序</h2><h5 id="①不希望小程序被催肥"><a href="#①不希望小程序被催肥" class="headerlink" title="①不希望小程序被催肥"></a>①不希望小程序被催肥</h5><p>对小程序的发展，我们需要足够的耐心，我们需要更长的周期去铺垫它，让它慢慢成长，希望大家和我们一样，有足够耐心。针对线下的场景，我们希望通过小程序作为万事万物的一个表达语言，做沟通的一种信息组织方式。  </p><h5 id="②小程序不是专门为某一个领域准备的，希望把它做得足够抽象"><a href="#②小程序不是专门为某一个领域准备的，希望把它做得足够抽象" class="headerlink" title="②小程序不是专门为某一个领域准备的，希望把它做得足够抽象"></a>②小程序不是专门为某一个领域准备的，希望把它做得足够抽象</h5><h5 id="③小程序不做中心化入口"><a href="#③小程序不做中心化入口" class="headerlink" title="③小程序不做中心化入口"></a>③小程序不做中心化入口</h5><p>我们希望小程序是基于去中心化而存在的更大的平台。在新版本里，很多人觉得微信给了小程序入口，通过首页下拉，看一弹出小程序。事实上它只是一个任务栏，一个快捷方式，相信用过windows系统的都不陌生，每个小程序右上角的圆点，点击可以关闭小程序，长按可以切换，所以这对我们来说是一个任务栏，一种切换方式。<br>对于小程序和App的关系，小程序不会去取代App，反而是去丰富App的很多场景，很多场景App会比较笨重，不太方便，小程序可以来弥补。<br>对于线下，我们希望小程序的触达是通过扫码，甚至有一天通过一个眼镜直接可以打开一个小程序，真正能够做到，看到一个场景或者事物，就可以立即打开小程序，而不是去下载一个App。<br>对于线上，我们希望小程序的触达是通过搜索来做到。  </p><h2 id="8，小游戏"><a href="#8，小游戏" class="headerlink" title="8，小游戏"></a>8，小游戏</h2><p>我们希望微信平台有很多高水平的小游戏，玩一个小游戏变成一个正经事，而不是浪费时间。  </p><h2 id="9，企业微信"><a href="#9，企业微信" class="headerlink" title="9，企业微信"></a>9，企业微信</h2><p>微信和企业微信可以互通。企业员工不需要用自己的个人微信去添加一些微信的客户，而是直接通过企业的微信就可以做到沟通，这是关于企业微信的下一步展望。  </p><h2 id="10，微信的未来发展"><a href="#10，微信的未来发展" class="headerlink" title="10，微信的未来发展"></a>10，微信的未来发展</h2><p>探索线下生活。</p>]]></content>
      
      
      <categories>
          
          <category> 资讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资讯 </tag>
            
            <tag> 微信 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO个人博客主题配置</title>
      <link href="/2017/11/29/hexo-ge-ren-bo-ke-zhu-ti-pei-zhi/"/>
      <url>/2017/11/29/hexo-ge-ren-bo-ke-zhu-ti-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="/uploads/head_theme/theme2.jpg" width="100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇我们介绍了个人博客的搭建，考虑到篇幅太长不利于阅读，所以上一篇只完成了本地博客的搭建。本文将会介绍如何将本地博客同步到github以及绑定自己的域名，还会涉及一些基础配置、主题的修改、以及接入第三方的一些工具。</p><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>首先需要注册一个Github的账号，注册过程这里不多说，然后创建一个Repository，并且命名：你的Github的名字.github.io ，这里名字很重要不能乱取，要严格按照要求来。<br>创建好Github的Repository之后，我们打开cmd命令工具，ping 你的Github的名字.github.io，这样我们就可以得到对应的IP地址。注册一个自己的域名，这里我是在阿里云上注册购买的域名，以自己名字命名的，结尾优先使用.com或者.cn，如果被注册了再使用其他的，看个人喜好吧。然后在阿里云控制台里面配置域名解析到我们刚刚ping出的IP地址。<br>打开阿里云域名解析列表，如下图：<br><img src="/uploads/pic14.png" alt=""><br>点击需要解析的域名后面对应的“解析设置”按钮，进入解析页面，点击添加解析按钮，添加对应的数据，如图：<br><img src="/uploads/pic15.png" alt=""><br>到这里，我们就将域名和我们的Repository绑定了，接下来只需要将本地博客同步到Repository就可以通过域名访问了。  </p><h3 id="同步到Github："><a href="#同步到Github：" class="headerlink" title="同步到Github："></a>同步到Github：</h3><p>找到之前创建的站点目录下，用git命令clone之前新建的仓库到本地，命令：<br>git clone <a href="https://github.com/你的github名字/你的github名字.github.io" target="_blank" rel="noopener">https://github.com/你的github名字/你的github名字.github.io</a> .deploy/你的github名字.github.io<br>然后在HEXO站点目录下创建一个deploy.txt文档，写入命令：<br>hexo generate<br>xcopy  public /s .deploy/你的github名字.github.io<br>cd .deploy/你的github名字.github.io<br>git add .<br>git commit -m “update”<br>git push origin master<br>然后将扩展名改为sh，就变成一个同步代码的脚本deploy.sh。双击这个文件，然后按要求输入Github的用户名和密码就可以了（这是windows下的命令，linux下自己稍作修改）。然后我们直接输入域名就可以访问我们的博客了。  </p><h1 id="站点主题配置："><a href="#站点主题配置：" class="headerlink" title="站点主题配置："></a>站点主题配置：</h1><p>爱美之心人皆有之，下面我们将介绍一下如何将我们的博客修改得更酷一点。我们这里主要使用的是NEXT模板关于NEXT可以到<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NEXT主题</a>了解更多。<br>在站点目录下，执行git命令，加载next模板代码到本地。<br>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next    </p><h3 id="站点配置："><a href="#站点配置：" class="headerlink" title="站点配置："></a>站点配置：</h3><p>找到站点目录下的_config.yml文件，打开（这里推荐使用MarkdownPad作为编辑工具<a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a>），设置站点的标题、作者、语言等。  </p><pre><code># Sitetitle: Hexo博客      subtitle: 新的开始   description: blog.fens.me   author: bsspirit  email: bsspirit@gmail.com  language: zh-Hans</code></pre><p>设置了中文需要将language设置成zh-Hans，具体语言表请看官网NEXT主题。有的发现设置了中文language，填写的中文是乱码，这是文件编码格式不对，将文件另存为UTF-8格式，覆盖原来的，就可以了。</p><h3 id="主题配置："><a href="#主题配置：" class="headerlink" title="主题配置："></a>主题配置：</h3><p>找到HEXO站点目录下的themes目录下next目录下的_config.yml主题配置文件，找到并修改修改scheme属性，选择自己喜欢的外观，这里我选择Mist主题。<br><img src="/uploads/pic16.png" alt=""><br><img src="/uploads/pic13.png" alt=""><br>在主题配置文件里面找到avatar配置，这里是设置头像的，配置好头像地址就好了。<br><img src="/uploads/pic17.png" alt=""><br><img src="/uploads/pic18.png" alt=""><br>在主题配置文件里面，找到menu设置，选择需要的menu放出来：<br><img src="/uploads/pic19.png" alt=""><br><img src="/uploads/pic20.png" alt=""><br>原来默认有首页和归档两个标签，这里我放出了分类和关于两个标签，需要创建对应的index页面。<br>分类页面：在站点目录下执行命令  </p><pre>hexo new page categories</pre>关于页面：在站点目录下执行命令  <pre>hexo new page categories  </pre>  ### 站点底部配置：找到\themes\next\layout\_partials下的footer.swig文件，找到<pre>theme.footer.powered</pre><pre>theme.footer.powered and theme.footer.theme.enable</pre><pre>theme.footer.theme.enable</pre>下的内容，可以对底部展示文字格式做调整，在\themes\next\languages文件夹下的zh-Hans.yml中找到footer关键字，可以对展示内容做修改。  <pre><code>footer:    powered: "怠惰是贫穷的制造厂"    theme: Never say die.  </code></pre>    <h3 id="社交链接配置："><a href="#社交链接配置：" class="headerlink" title="社交链接配置："></a>社交链接配置：</h3><p>在主题配置文件中找到social配置，选择自己需要的站点配置链接。<br><img src="/uploads/pic21.png">   </p><h1 id="第三方功能接入："><a href="#第三方功能接入：" class="headerlink" title="第三方功能接入："></a>第三方功能接入：</h1><h3 id="评论系统："><a href="#评论系统：" class="headerlink" title="评论系统："></a>评论系统：</h3><p>这里使用的gitment评论，点开链接gitment注册，  Authorization callback URL填写自己的网站链接，记下Client ID和Client Secret。在主题配置文件中找到Gitment配置  </p><pre><code>gitment:    enable: true    mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway    count: true # Show comments count in post meta area    lazy: false # Comments lazy loading with a button    cleanly: true # Hide 'Powered by ...' on footer, and more    language: zh-Hans # Force language, or auto switch by theme    github_user: # MUST HAVE, Your Github ID    github_repo: # MUST HAVE, The repo you use to store Gitment comments    client_id: # MUST HAVE, Github client id for the Gitment    client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment    proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect    redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled </code></pre>  对应的都填上就好了。  在languages目录下en.yml中添加：<pre><code>gitmentbutton: Show comments from Gitment  </code></pre>  在zh-Hans.yml里面添加：<pre><code>gitmentbutton: 显示 Gitment 评论  </code></pre>在layout/_partials/comments.swig中找到  <img src="/uploads/pic24.png">  在下面再加一个分支  <img src="/uploads/pic22.png">  在layout/_third-party/comments/目录下中添加文件gitment.swig（这里代码比较多，直接放链接下载文件<a href="/uploads/gitment.swig">gitment.swig</a>）。<br>  然后在主题下layout/_third-party/comments/index.swig文件中引入上面的文件：  <img src="/uploads/pic23.png">  在source/css/_common/components/third-party/目录下添加gitment.styl文件，设置button的样式：   <pre><code>#gitment-display-button{       display: inline-block;       padding: 0 15px;       color: #0a9caf;       cursor: pointer;       font-size: 14px;       border: 1px solid #0a9caf;       border-radius: 4px;   }   #gitment-display-button:hover{       color: #fff;       background: #0a9caf;   } </code></pre>  <p>在source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式即可:  </p><blockquote><p>@import “gitment”;  </p></blockquote><p>这样就可以了。</p><p>文末添加结束语：<br>在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：<br><img src="/uploads/pic31.png" alt=""><br>接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer之前添加如下画红色部分代码（post-footer之前两个DIV）：如下大概在360行左右的位置：<br><img src="/uploads/pic25.png" alt=""><br><img src="/uploads/pic26.png" alt=""><br>最后在主题配置文件末尾添加：<br><img src="/uploads/pic27.png" alt=""><br>底部显示访问量：<br>打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这话：<br><img src="/uploads/pic28.png" alt=""><br>然后再合适的位置添加显示统计的代码(位置还是上述这个文件)，如图：<br><img src="/uploads/pic29.png" alt=""><br><img src="/uploads/pic30.png" alt="">   </p><p>到这里就结束了。</p><p>添加百度统计，阅读次数都可以在官网看到<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-system" target="_blank" rel="noopener">百度统计</a>，这里不多说了。  </p><p>本文在参考一些技术文章的基础上实践过，整理了相关流程，感谢相关分享的作者，这里附链接：<br><a href="http://blog.csdn.net/yanzi1225627/article/details/77890414" target="_blank" rel="noopener">hexo next主题集成gitment评论系统</a><br><a href="http://blog.csdn.net/linshuhe1/article/details/52424573" target="_blank" rel="noopener">Hexo个人免费博客(三) next主题、评论、阅读量统计和站内搜索</a><br><a href="http://blog.csdn.net/w_ngzeqi/article/details/73863543" target="_blank" rel="noopener">hexo之next主题个性化配置详细教程</a><br><a href="https://mp.weixin.qq.com/s/EUyO-7ESonfSQpD5GcCiQw" target="_blank" rel="noopener">搭建个人博客</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 搭建部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO个人博客搭建教程</title>
      <link href="/2017/11/28/hexo-ge-ren-bo-ke-da-jian-jiao-cheng/"/>
      <url>/2017/11/28/hexo-ge-ren-bo-ke-da-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="/uploads/head_theme/theme1.jpg" width="100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直有搭建一个个人博客的想法，直到一次偶然看到大神分享的Hexo+Next+Github搭建个人博客的教程，心血来潮，搭建了一个自己的博客，圆了梦，也是新梦的启航。<br>搜查了无数资料，总算搭建完成，在此分享下搭建的过程，以便自己回顾，也方便想搭建自己博客的童鞋。</p><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>安装Hexo之前，我们首先需要安装nodejs和git。<br>Nodejs：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a><br>下载下来按步骤点击安装就好了，安装好之后测试下看是否安装完成，在cmd输入命令node -v，看到打印出版本号，说明nodejs安装正确<br><img src="/uploads/pic1.jpg" alt=""><br>nodejs里面封装了npm，cmd输入命令npm -v，看到效果<br><img src="/uploads/pic2.jpg" alt="">  </p><p>Git：<a href="https://git-scm.com/" target="_blank" rel="noopener">下载地址</a><br>下载后点击安装，安装好之后，cmd输入git命令测试，看到如下效果，说明成功。<br><img src="/uploads/pic3.jpg" alt="">  </p><h1 id="安装HEXO"><a href="#安装HEXO" class="headerlink" title="安装HEXO"></a>安装HEXO</h1><p>上面的准备工作做完了，我们可以安装Hexo了，cmd输入命令npm install -g hexo-cli。<br>安装完成后，新建一个文件夹，作为我们的站点目录，在目录下依次执行命令<br>hexo init<br>hexo g<br>hexo s<br><img src="/uploads/pic4.jpg" alt="">  </p><p>现在我们就可以在浏览器输入：<a href="http://localhost:4000/就可以看到效果了。" target="_blank" rel="noopener">http://localhost:4000/就可以看到效果了。</a><br>等等，和说好的好像不一样，并没有出现我想要的效果<br><img src="/uploads/pic5.jpg" alt=""><br>我们查一下4000端口使用情况，发现被占用了<br><img src="/uploads/pic6.jpg" alt=""><br><img src="/uploads/pic7.jpg" alt=""><br><img src="/uploads/pic8.jpg" alt=""><br>最后查到是被福昕阅读器的一个文档安全防护进程占用了。<br>4000端口无法使用，Ctrl+c结束服务，输入命令hexo s -p 5000，切换到5000端口，启动好后，访问<a href="http://localhost:5000/，看到了效果" target="_blank" rel="noopener">http://localhost:5000/，看到了效果</a><br><img src="/uploads/pic9.jpg" alt="">  </p><h1 id="NEXT主题"><a href="#NEXT主题" class="headerlink" title="NEXT主题"></a>NEXT主题</h1><p>定位到HEXO 站点目录下，执行命令git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br><img src="/uploads/pic10.jpg" alt=""><br>导入next主题文件<br>修改站点目录下的_config.yml配置文件中的theme属性，改成next<br>重新生成hexo g<br>启动hexo s -p 5000<br>看到next主题效果<br><img src="/uploads/pic11.jpg" alt=""><br>到这里本地的博客雏形就出来了。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
